/*
 * Copyright (c) 2014 T-Systems Multimedia Solutions GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * AppMon Server REST API
 * The AppMon Server exposes management and integration functionality via REST endpoints. This interactive documentation also acts as a REST client you can use to interact with the AppMon Server.  The HTTP status code of the response shows the result of your request. The expected response code for a successful request is documented individually per REST endpoint. Additionally the following error response codes can typically occur in our REST interface:  * **400** - Bad Request: Some request parameters are not correct. * **401** - Unauthorized: A valid authorization header (Basic Authentication) is required but is not available. * **403** - Forbidden: Execution of request is not allowed, e.g. the user has no privileges. * **404** - Not Found: Endpoint does not exist or some entities could not be found, e.g. System Profile. * **500** - Internal Server Error: See response body for details.  Additional [usage examples](https://www.dynatrace.com/support/doc/appmon70/shortlink/id_server_rest_examples) can be found in the AppMon documentation. 
 *
 * OpenAPI spec version: 2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package de.tsystems.mms.apm.performancesignature.dynatrace.rest.json.api;

import com.google.gson.reflect.TypeToken;
import com.squareup.okhttp.Call;
import com.squareup.okhttp.Interceptor;
import com.squareup.okhttp.Response;
import de.tsystems.mms.apm.performancesignature.dynatrace.rest.json.*;
import de.tsystems.mms.apm.performancesignature.dynatrace.rest.json.model.RecordingStatus;
import de.tsystems.mms.apm.performancesignature.dynatrace.rest.json.model.SessionRecordingOptions;
import de.tsystems.mms.apm.performancesignature.dynatrace.rest.json.model.SessionStoringOptions;
import org.apache.commons.io.FilenameUtils;

import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class LiveSessionsApi {
    private ApiClient apiClient;

    public LiveSessionsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public LiveSessionsApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for getRecording
     *
     * @param profileid               System Profile id (required)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call getRecordingCall(String profileid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // create path and map variables
        String localVarPath = "/profiles/{profileid}/session/recording/status"
                .replaceAll("\\{" + "profileid" + "\\}", apiClient.escapeString(profileid));

        List<Pair> localVarQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            });
        }

        String[] localVarAuthNames = new String[]{"basicAuth"};
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, null, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call getRecordingValidateBeforeCall(String profileid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'profileid' is set
        if (profileid == null) {
            throw new ApiException("Missing the required parameter 'profileid' when calling getRecording(Async)");
        }

        return getRecordingCall(profileid, progressListener, progressRequestListener);
    }

    /**
     * Get session recording status
     * Check if the live session is currently being recorded.
     *
     * @param profileid System Profile id (required)
     * @return RecordingStatus
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public RecordingStatus getRecording(String profileid) throws ApiException {
        ApiResponse<RecordingStatus> resp = getRecordingWithHttpInfo(profileid);
        return resp.getData();
    }

    /**
     * Get session recording status
     * Check if the live session is currently being recorded.
     *
     * @param profileid System Profile id (required)
     * @return ApiResponse&lt;RecordingStatus&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<RecordingStatus> getRecordingWithHttpInfo(String profileid) throws ApiException {
        Call call = getRecordingValidateBeforeCall(profileid, null, null);
        Type localVarReturnType = new TypeToken<RecordingStatus>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Build call for postRecording
     *
     * @param profileid               System Profile id (required)
     * @param body                    Session recording options (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call postRecordingCall(String profileid, SessionRecordingOptions body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // create path and map variables
        String localVarPath = "/profiles/{profileid}/session/recording"
                .replaceAll("\\{" + "profileid" + "\\}", apiClient.escapeString(profileid));

        List<Pair> localVarQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
                "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            });
        }

        String[] localVarAuthNames = new String[]{"basicAuth"};
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, body, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call postRecordingValidateBeforeCall(String profileid, SessionRecordingOptions body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'profileid' is set
        if (profileid == null) {
            throw new ApiException("Missing the required parameter 'profileid' when calling postRecording(Async)");
        }

        return postRecordingCall(profileid, body, progressListener, progressRequestListener);
    }

    /**
     * Start session recording
     * Start session recording for a specific System Profile. Starting session recording is only possible for pre-production licenses.
     *
     * @param profileid System Profile id (required)
     * @param body      Session recording options (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String postRecording(String profileid, SessionRecordingOptions body) throws ApiException {
        ApiResponse<Void> response = postRecordingWithHttpInfo(profileid, body);
        List<String> location = response.getHeaders().get("Location");
        return FilenameUtils.getName(location.get(0));
    }

    /**
     * Start session recording
     * Start session recording for a specific System Profile. Starting session recording is only possible for pre-production licenses.
     *
     * @param profileid System Profile id (required)
     * @param body      Session recording options (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> postRecordingWithHttpInfo(String profileid, SessionRecordingOptions body) throws ApiException {
        Call call = postRecordingValidateBeforeCall(profileid, body, null, null);
        return apiClient.execute(call);
    }

    /**
     * Build call for stopRecording
     *
     * @param profileid               System Profile id (required)
     * @param body                    (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call stopRecordingCall(String profileid, RecordingStatus body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // create path and map variables
        String localVarPath = "/profiles/{profileid}/session/recording/status"
                .replaceAll("\\{" + "profileid" + "\\}", apiClient.escapeString(profileid));

        List<Pair> localVarQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
                "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            });
        }

        String[] localVarAuthNames = new String[]{"basicAuth"};
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, body, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call stopRecordingValidateBeforeCall(String profileid, RecordingStatus body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'profileid' is set
        if (profileid == null) {
            throw new ApiException("Missing the required parameter 'profileid' when calling stopRecording(Async)");
        }

        return stopRecordingCall(profileid, body, progressListener, progressRequestListener);
    }

    /**
     * Stop session recording
     * Set recording status to false in order to stop session recording and create a reference to the stored session. This call does not complete until all recorded data is fully processed on the Server. Depending on the environment, it can take a few minutes until an HTTP response message is received. Stopping session recording is only possible for pre-production licenses.
     *
     * @param profileid System Profile id (required)
     * @param body      (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String stopRecording(String profileid, RecordingStatus body) throws ApiException {
        ApiResponse<Void> response = stopRecordingWithHttpInfo(profileid, body);
        List<String> location = response.getHeaders().get("Location");
        return FilenameUtils.getName(location.get(0));
    }

    /**
     * Stop session recording
     * Set recording status to false in order to stop session recording and create a reference to the stored session. This call does not complete until all recorded data is fully processed on the Server. Depending on the environment, it can take a few minutes until an HTTP response message is received. Stopping session recording is only possible for pre-production licenses.
     *
     * @param profileid System Profile id (required)
     * @param body      (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> stopRecordingWithHttpInfo(String profileid, RecordingStatus body) throws ApiException {
        Call call = stopRecordingValidateBeforeCall(profileid, body, null, null);
        return apiClient.execute(call);
    }

    /**
     * Build call for storeSession
     *
     * @param profileid               System Profile id (required)
     * @param body                    Session storing options (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call storeSessionCall(String profileid, SessionStoringOptions body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // create path and map variables
        String localVarPath = "/profiles/{profileid}/session/store"
                .replaceAll("\\{" + "profileid" + "\\}", apiClient.escapeString(profileid));

        List<Pair> localVarQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
                "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            });
        }

        String[] localVarAuthNames = new String[]{"basicAuth"};
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, body, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call storeSessionValidateBeforeCall(String profileid, SessionStoringOptions body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'profileid' is set
        if (profileid == null) {
            throw new ApiException("Missing the required parameter 'profileid' when calling storeSession(Async)");
        }

        return storeSessionCall(profileid, body, progressListener, progressRequestListener);
    }

    /**
     * Store session
     * Store all time series and PurePaths in the Server&#39;s memory to a stored session. To limit the data to be stored, specify a start time and end time in the request body, otherwise the last 30 minutes will be stored.
     *
     * @param profileid System Profile id (required)
     * @param body      Session storing options (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String storeSession(String profileid, SessionStoringOptions body) throws ApiException {
        ApiResponse<Void> response = storeSessionWithHttpInfo(profileid, body);
        List<String> location = response.getHeaders().get("Location");
        return FilenameUtils.getName(location.get(0));
    }

    /**
     * Store session
     * Store all time series and PurePaths in the Server&#39;s memory to a stored session. To limit the data to be stored, specify a start time and end time in the request body, otherwise the last 30 minutes will be stored.
     *
     * @param profileid System Profile id (required)
     * @param body      Session storing options (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> storeSessionWithHttpInfo(String profileid, SessionStoringOptions body) throws ApiException {
        Call call = storeSessionValidateBeforeCall(profileid, body, null, null);
        return apiClient.execute(call);
    }
}
