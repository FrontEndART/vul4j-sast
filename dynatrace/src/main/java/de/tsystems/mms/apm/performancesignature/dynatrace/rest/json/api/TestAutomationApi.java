/*
 * Copyright (c) 2014 T-Systems Multimedia Solutions GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * AppMon Server REST API
 * The AppMon Server exposes management and integration functionality via REST endpoints. This interactive documentation also acts as a REST client you can use to interact with the AppMon Server.  The HTTP status code of the response shows the result of your request. The expected response code for a successful request is documented individually per REST endpoint. Additionally the following error response codes can typically occur in our REST interface:  * **400** - Bad Request: Some request parameters are not correct. * **401** - Unauthorized: A valid authorization header (Basic Authentication) is required but is not available. * **403** - Forbidden: Execution of request is not allowed, e.g. the user has no privileges. * **404** - Not Found: Endpoint does not exist or some entities could not be found, e.g. System Profile. * **500** - Internal Server Error: See response body for details.  Additional [usage examples](https://www.dynatrace.com/support/doc/appmon70/shortlink/id_server_rest_examples) can be found in the AppMon documentation. 
 *
 * OpenAPI spec version: 2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package de.tsystems.mms.apm.performancesignature.dynatrace.rest.json.api;

import com.google.gson.reflect.TypeToken;
import com.squareup.okhttp.Call;
import com.squareup.okhttp.Interceptor;
import com.squareup.okhttp.Response;
import de.tsystems.mms.apm.performancesignature.dynatrace.model.TestRun;
import de.tsystems.mms.apm.performancesignature.dynatrace.rest.json.*;
import de.tsystems.mms.apm.performancesignature.dynatrace.rest.json.model.ExternalTest;
import de.tsystems.mms.apm.performancesignature.dynatrace.rest.json.model.TestRunDefinition;
import de.tsystems.mms.apm.performancesignature.dynatrace.rest.json.model.TestRunFilter;
import de.tsystems.mms.apm.performancesignature.dynatrace.rest.json.model.TestRuns;

import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class TestAutomationApi {
    private ApiClient apiClient;

    public TestAutomationApi() {
        this(Configuration.getDefaultApiClient());
    }

    public TestAutomationApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for finishTestRun
     *
     * @param profileid               System profile id (required)
     * @param testrunid               UUID of the test run (required)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call finishTestRunCall(String profileid, String testrunid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // create path and map variables
        String localVarPath = "/profiles/{profileid}/testruns/{testrunid}/finish"
                .replaceAll("\\{" + "profileid" + "\\}", apiClient.escapeString(profileid))
                .replaceAll("\\{" + "testrunid" + "\\}", apiClient.escapeString(testrunid));

        List<Pair> localVarQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            });
        }

        String[] localVarAuthNames = new String[]{"basicAuth"};
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, null, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call finishTestRunValidateBeforeCall(String profileid, String testrunid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'profileid' is set
        if (profileid == null) {
            throw new ApiException("Missing the required parameter 'profileid' when calling finishTestRun(Async)");
        }

        // verify the required parameter 'testrunid' is set
        if (testrunid == null) {
            throw new ApiException("Missing the required parameter 'testrunid' when calling finishTestRun(Async)");
        }

        return finishTestRunCall(profileid, testrunid, progressListener, progressRequestListener);
    }

    /**
     * Mark test run as finished
     * Returns all test run details (including test executions) of a finished test run.
     *
     * @param profileid System profile id (required)
     * @param testrunid UUID of the test run (required)
     * @return TestRun
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public TestRun finishTestRun(String profileid, String testrunid) throws ApiException {
        ApiResponse<TestRun> resp = finishTestRunWithHttpInfo(profileid, testrunid);
        return resp.getData();
    }

    /**
     * Mark test run as finished
     * Returns all test run details (including test executions) of a finished test run.
     *
     * @param profileid System profile id (required)
     * @param testrunid UUID of the test run (required)
     * @return ApiResponse&lt;TestRun&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<TestRun> finishTestRunWithHttpInfo(String profileid, String testrunid) throws ApiException {
        Call call = finishTestRunValidateBeforeCall(profileid, testrunid, null, null);
        Type localVarReturnType = new TypeToken<TestRun>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Build call for getTestRuns
     *
     * @param profileid               System profile id (required)
     * @param startTime               Start time (ISO 8601) - default is 1st of January 1970 00:00 (optional)
     * @param endTime                 End time (ISO 8601) - default is current time (optional)
     * @param lastNTestruns           Max number of the most recent test runs to include (optional)
     * @param lastNBuilds             Max number of the most recent builds (versionBuild) values to include (optional)
     * @param extend                  Level of detail returned in the response: - &#39;runs&#39;: only meta data, - &#39;results&#39;: meta data and individual test results, - &#39;measures&#39;: meta data, test results and measure values (optional, default to runs)
     * @param finished                Finished state (optional)
     * @param status                  Filter by status (optional)
     * @param versionMilestone        Filter by versionMilestone (optional)
     * @param versionMajor            Filter by versionMajor (optional)
     * @param versionMinor            Filter by versionMinor (optional)
     * @param versionRevision         Filter by versionRevision (optional)
     * @param versionBuild            Filter by versionBuild (optional)
     * @param category                Filter by category (unit, uidriven, performance, webapi) (optional)
     * @param marker                  Filter by marker (optional)
     * @param platform                Filter by platform (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call getTestRunsCall(String profileid, String startTime, String endTime, Integer lastNTestruns, Integer lastNBuilds, String extend, Boolean finished, List<String> status, List<String> versionMilestone, List<String> versionMajor, List<String> versionMinor, List<String> versionRevision, List<String> versionBuild, List<String> category, List<String> marker, List<String> platform, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // create path and map variables
        String localVarPath = "/profiles/{profileid}/testruns"
                .replaceAll("\\{" + "profileid" + "\\}", apiClient.escapeString(profileid));

        List<Pair> localVarQueryParams = new ArrayList<>();
        if (startTime != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "startTime", startTime));
        if (endTime != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "endTime", endTime));
        if (lastNTestruns != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "lastNTestruns", lastNTestruns));
        if (lastNBuilds != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "lastNBuilds", lastNBuilds));
        if (extend != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "extend", extend));
        if (finished != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "finished", finished));
        if (status != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "status", status));
        if (versionMilestone != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "versionMilestone", versionMilestone));
        if (versionMajor != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "versionMajor", versionMajor));
        if (versionMinor != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "versionMinor", versionMinor));
        if (versionRevision != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "versionRevision", versionRevision));
        if (versionBuild != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "versionBuild", versionBuild));
        if (category != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "category", category));
        if (marker != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "marker", marker));
        if (platform != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("multi", "platform", platform));

        Map<String, String> localVarHeaderParams = new HashMap<>();

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            });
        }

        String[] localVarAuthNames = new String[]{"basicAuth"};
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, null, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call getTestRunsValidateBeforeCall(String profileid, String startTime, String endTime, Integer lastNTestruns, Integer lastNBuilds, String extend, Boolean finished, List<String> status, List<String> versionMilestone, List<String> versionMajor, List<String> versionMinor, List<String> versionRevision, List<String> versionBuild, List<String> category, List<String> marker, List<String> platform, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'profileid' is set
        if (profileid == null) {
            throw new ApiException("Missing the required parameter 'profileid' when calling getTestRuns(Async)");
        }

        return getTestRunsCall(profileid, startTime, endTime, lastNTestruns, lastNBuilds, extend, finished, status, versionMilestone, versionMajor, versionMinor, versionRevision, versionBuild, category, marker, platform, progressListener, progressRequestListener);
    }

    /**
     * List test runs by System Profile
     * Get a list of registered test runs for given System Profile that have test executions. The level of detail can be controlled with the &#39;extend&#39; query parameter.
     *
     * @param profileid        System profile id (required)
     * @param startTime        Start time (ISO 8601) - default is 1st of January 1970 00:00 (optional)
     * @param endTime          End time (ISO 8601) - default is current time (optional)
     * @param lastNTestruns    Max number of the most recent test runs to include (optional)
     * @param lastNBuilds      Max number of the most recent builds (versionBuild) values to include (optional)
     * @param extend           Level of detail returned in the response: - &#39;runs&#39;: only meta data, - &#39;results&#39;: meta data and individual test results, - &#39;measures&#39;: meta data, test results and measure values (optional, default to runs)
     * @param finished         Finished state (optional)
     * @param status           Filter by status (optional)
     * @param versionMilestone Filter by versionMilestone (optional)
     * @param versionMajor     Filter by versionMajor (optional)
     * @param versionMinor     Filter by versionMinor (optional)
     * @param versionRevision  Filter by versionRevision (optional)
     * @param versionBuild     Filter by versionBuild (optional)
     * @param category         Filter by category (unit, uidriven, performance, webapi) (optional)
     * @param marker           Filter by marker (optional)
     * @param platform         Filter by platform (optional)
     * @return TestRuns
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public TestRuns getTestRuns(String profileid, String startTime, String endTime, Integer lastNTestruns, Integer lastNBuilds, String extend, Boolean finished, List<String> status, List<String> versionMilestone, List<String> versionMajor, List<String> versionMinor, List<String> versionRevision, List<String> versionBuild, List<String> category, List<String> marker, List<String> platform) throws ApiException {
        ApiResponse<TestRuns> resp = getTestRunsWithHttpInfo(profileid, startTime, endTime, lastNTestruns, lastNBuilds, extend, finished, status, versionMilestone, versionMajor, versionMinor, versionRevision, versionBuild, category, marker, platform);
        return resp.getData();
    }

    /**
     * List test runs by System Profile
     * Get a list of registered test runs for given System Profile that have test executions. The level of detail can be controlled with the &#39;extend&#39; query parameter.
     *
     * @param profileid        System profile id (required)
     * @param startTime        Start time (ISO 8601) - default is 1st of January 1970 00:00 (optional)
     * @param endTime          End time (ISO 8601) - default is current time (optional)
     * @param lastNTestruns    Max number of the most recent test runs to include (optional)
     * @param lastNBuilds      Max number of the most recent builds (versionBuild) values to include (optional)
     * @param extend           Level of detail returned in the response: - &#39;runs&#39;: only meta data, - &#39;results&#39;: meta data and individual test results, - &#39;measures&#39;: meta data, test results and measure values (optional, default to runs)
     * @param finished         Finished state (optional)
     * @param status           Filter by status (optional)
     * @param versionMilestone Filter by versionMilestone (optional)
     * @param versionMajor     Filter by versionMajor (optional)
     * @param versionMinor     Filter by versionMinor (optional)
     * @param versionRevision  Filter by versionRevision (optional)
     * @param versionBuild     Filter by versionBuild (optional)
     * @param category         Filter by category (unit, uidriven, performance, webapi) (optional)
     * @param marker           Filter by marker (optional)
     * @param platform         Filter by platform (optional)
     * @return ApiResponse&lt;TestRuns&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<TestRuns> getTestRunsWithHttpInfo(String profileid, String startTime, String endTime, Integer lastNTestruns, Integer lastNBuilds, String extend, Boolean finished, List<String> status, List<String> versionMilestone, List<String> versionMajor, List<String> versionMinor, List<String> versionRevision, List<String> versionBuild, List<String> category, List<String> marker, List<String> platform) throws ApiException {
        Call call = getTestRunsValidateBeforeCall(profileid, startTime, endTime, lastNTestruns, lastNBuilds, extend, finished, status, versionMilestone, versionMajor, versionMinor, versionRevision, versionBuild, category, marker, platform, null, null);
        Type localVarReturnType = new TypeToken<TestRuns>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Build call for getTestrunById
     *
     * @param profileid               System profile id (required)
     * @param testrunid               UUID of the test run (required)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call getTestrunByIdCall(String profileid, String testrunid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // create path and map variables
        String localVarPath = "/profiles/{profileid}/testruns/{testrunid}"
                .replaceAll("\\{" + "profileid" + "\\}", apiClient.escapeString(profileid))
                .replaceAll("\\{" + "testrunid" + "\\}", apiClient.escapeString(testrunid));

        List<Pair> localVarQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            });
        }

        String[] localVarAuthNames = new String[]{"basicAuth"};
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, null, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call getTestrunByIdValidateBeforeCall(String profileid, String testrunid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'profileid' is set
        if (profileid == null) {
            throw new ApiException("Missing the required parameter 'profileid' when calling getTestrunById(Async)");
        }

        // verify the required parameter 'testrunid' is set
        if (testrunid == null) {
            throw new ApiException("Missing the required parameter 'testrunid' when calling getTestrunById(Async)");
        }

        return getTestrunByIdCall(profileid, testrunid, progressListener, progressRequestListener);
    }

    /**
     * Get test run by id
     * Get all test run details including test executions.
     *
     * @param profileid System profile id (required)
     * @param testrunid UUID of the test run (required)
     * @return TestRun
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public TestRun getTestrunById(String profileid, String testrunid) throws ApiException {
        ApiResponse<TestRun> resp = getTestrunByIdWithHttpInfo(profileid, testrunid);
        return resp.getData();
    }

    /**
     * Get test run by id
     * Get all test run details including test executions.
     *
     * @param profileid System profile id (required)
     * @param testrunid UUID of the test run (required)
     * @return ApiResponse&lt;TestRun&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<TestRun> getTestrunByIdWithHttpInfo(String profileid, String testrunid) throws ApiException {
        Call call = getTestrunByIdValidateBeforeCall(profileid, testrunid, null, null);
        Type localVarReturnType = new TypeToken<TestRun>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Build call for invalidateTestRun
     *
     * @param profileid               System profile id (required)
     * @param testrunid               UUID of the test run (required)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call invalidateTestRunCall(String profileid, String testrunid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // create path and map variables
        String localVarPath = "/profiles/{profileid}/testruns/{testrunid}/invalidate"
                .replaceAll("\\{" + "profileid" + "\\}", apiClient.escapeString(profileid))
                .replaceAll("\\{" + "testrunid" + "\\}", apiClient.escapeString(testrunid));

        List<Pair> localVarQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            });
        }

        String[] localVarAuthNames = new String[]{"basicAuth"};
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, null, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call invalidateTestRunValidateBeforeCall(String profileid, String testrunid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'profileid' is set
        if (profileid == null) {
            throw new ApiException("Missing the required parameter 'profileid' when calling invalidateTestRun(Async)");
        }

        // verify the required parameter 'testrunid' is set
        if (testrunid == null) {
            throw new ApiException("Missing the required parameter 'testrunid' when calling invalidateTestRun(Async)");
        }

        return invalidateTestRunCall(profileid, testrunid, progressListener, progressRequestListener);
    }

    /**
     * Mark test run as invalidated
     * Sets the test run state to INVALIDATED either for all test executions within that test run, or only executions of tests that matches &#39;testId&#39; (which can be package, or class or a single test). Returns all test run details (including test executions) of an invalidated test run.
     *
     * @param profileid System profile id (required)
     * @param testrunid UUID of the test run (required)
     * @return TestRun
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public TestRun invalidateTestRun(String profileid, String testrunid) throws ApiException {
        ApiResponse<TestRun> resp = invalidateTestRunWithHttpInfo(profileid, testrunid);
        return resp.getData();
    }

    /**
     * Mark test run as invalidated
     * Sets the test run state to INVALIDATED either for all test executions within that test run, or only executions of tests that matches &#39;testId&#39; (which can be package, or class or a single test). Returns all test run details (including test executions) of an invalidated test run.
     *
     * @param profileid System profile id (required)
     * @param testrunid UUID of the test run (required)
     * @return ApiResponse&lt;TestRun&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<TestRun> invalidateTestRunWithHttpInfo(String profileid, String testrunid) throws ApiException {
        Call call = invalidateTestRunValidateBeforeCall(profileid, testrunid, null, null);
        Type localVarReturnType = new TypeToken<TestRun>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Build call for markTestExecutionAsFailed
     *
     * @param profileid               System profile id (required)
     * @param testrunid               UUID of the test run (required)
     * @param testId                  Full test name including package description and class name (if applicable) (required)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call markTestExecutionAsFailedCall(String profileid, String testrunid, String testId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // create path and map variables
        String localVarPath = "/profiles/{profileid}/testruns/{testrunid}/markAsFailed"
                .replaceAll("\\{" + "profileid" + "\\}", apiClient.escapeString(profileid))
                .replaceAll("\\{" + "testrunid" + "\\}", apiClient.escapeString(testrunid));

        List<Pair> localVarQueryParams = new ArrayList<>();
        if (testId != null)
            localVarQueryParams.addAll(apiClient.parameterToPairs("", "testId", testId));

        Map<String, String> localVarHeaderParams = new HashMap<>();

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            });
        }

        String[] localVarAuthNames = new String[]{"basicAuth"};
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, null, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call markTestExecutionAsFailedValidateBeforeCall(String profileid, String testrunid, String testId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'profileid' is set
        if (profileid == null) {
            throw new ApiException("Missing the required parameter 'profileid' when calling markTestExecutionAsFailed(Async)");
        }

        // verify the required parameter 'testrunid' is set
        if (testrunid == null) {
            throw new ApiException("Missing the required parameter 'testrunid' when calling markTestExecutionAsFailed(Async)");
        }

        // verify the required parameter 'testId' is set
        if (testId == null) {
            throw new ApiException("Missing the required parameter 'testId' when calling markTestExecutionAsFailed(Async)");
        }

        return markTestExecutionAsFailedCall(profileid, testrunid, testId, progressListener, progressRequestListener);
    }

    /**
     * Set test execution&#39;s state to FAILED
     * Test execution is located using testRunId (UUID) and full test name (including package and class). Returns all details of a test run which is bound with marked test execution.
     *
     * @param profileid System profile id (required)
     * @param testrunid UUID of the test run (required)
     * @param testId    Full test name including package description and class name (if applicable) (required)
     * @return TestRun
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public TestRun markTestExecutionAsFailed(String profileid, String testrunid, String testId) throws ApiException {
        ApiResponse<TestRun> resp = markTestExecutionAsFailedWithHttpInfo(profileid, testrunid, testId);
        return resp.getData();
    }

    /**
     * Set test execution&#39;s state to FAILED
     * Test execution is located using testRunId (UUID) and full test name (including package and class). Returns all details of a test run which is bound with marked test execution.
     *
     * @param profileid System profile id (required)
     * @param testrunid UUID of the test run (required)
     * @param testId    Full test name including package description and class name (if applicable) (required)
     * @return ApiResponse&lt;TestRun&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<TestRun> markTestExecutionAsFailedWithHttpInfo(String profileid, String testrunid, String testId) throws ApiException {
        Call call = markTestExecutionAsFailedValidateBeforeCall(profileid, testrunid, testId, null, null);
        Type localVarReturnType = new TypeToken<TestRun>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Build call for postExternalTestData
     *
     * @param profileid               System profile id (required)
     * @param testrunid               UUID of the test run (required)
     * @param body                    Test result (required)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call postExternalTestDataCall(String profileid, String testrunid, ExternalTest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // create path and map variables
        String localVarPath = "/profiles/{profileid}/testruns/{testrunid}"
                .replaceAll("\\{" + "profileid" + "\\}", apiClient.escapeString(profileid))
                .replaceAll("\\{" + "testrunid" + "\\}", apiClient.escapeString(testrunid));

        List<Pair> localVarQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
                "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            });
        }

        String[] localVarAuthNames = new String[]{"basicAuth"};
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, body, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call postExternalTestDataValidateBeforeCall(String profileid, String testrunid, ExternalTest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'profileid' is set
        if (profileid == null) {
            throw new ApiException("Missing the required parameter 'profileid' when calling postExternalTestData(Async)");
        }

        // verify the required parameter 'testrunid' is set
        if (testrunid == null) {
            throw new ApiException("Missing the required parameter 'testrunid' when calling postExternalTestData(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling postExternalTestData(Async)");
        }

        return postExternalTestDataCall(profileid, testrunid, body, progressListener, progressRequestListener);
    }

    /**
     * Post test result
     * Post a test result for a registered test run of category &#39;external&#39;.
     *
     * @param profileid System profile id (required)
     * @param testrunid UUID of the test run (required)
     * @param body      Test result (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void postExternalTestData(String profileid, String testrunid, ExternalTest body) throws ApiException {
        postExternalTestDataWithHttpInfo(profileid, testrunid, body);
    }

    /**
     * Post test result
     * Post a test result for a registered test run of category &#39;external&#39;.
     *
     * @param profileid System profile id (required)
     * @param testrunid UUID of the test run (required)
     * @param body      Test result (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> postExternalTestDataWithHttpInfo(String profileid, String testrunid, ExternalTest body) throws ApiException {
        Call call = postExternalTestDataValidateBeforeCall(profileid, testrunid, body, null, null);
        return apiClient.execute(call);
    }

    /**
     * Build call for postTestRun
     *
     * @param profileid               System profile id (required)
     * @param body                    Test run parameters (required)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call postTestRunCall(String profileid, TestRunDefinition body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // create path and map variables
        String localVarPath = "/profiles/{profileid}/testruns"
                .replaceAll("\\{" + "profileid" + "\\}", apiClient.escapeString(profileid));

        List<Pair> localVarQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
                "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            });
        }

        String[] localVarAuthNames = new String[]{"basicAuth"};
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, body, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call postTestRunValidateBeforeCall(String profileid, TestRunDefinition body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'profileid' is set
        if (profileid == null) {
            throw new ApiException("Missing the required parameter 'profileid' when calling postTestRun(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling postTestRun(Async)");
        }

        return postTestRunCall(profileid, body, progressListener, progressRequestListener);
    }

    /**
     * Register test run
     * Register a test run with provided parameters. The reply contains all test run&#39;s details including the UUID.  - **category** is limited to one of the following values: &#39;unit&#39; (default), &#39;uidriven&#39;, &#39;performance&#39;, &#39;webapi&#39; or &#39;external&#39;. - **marker** is a label used in the Test Automation dashlet charts. - if the **platform** is left blank, the agent will detect it automatically. - if the **includedMetrics** is provided, only test results for these metrics will be collected in this test run. In order to collect all test results for a given metric group you can pass just the group name or leave the metric name blank. - **additionalMetaData** can be used to provide additional data stored in Test Run, like Jenkins build ID, list of commiters, etc. Example Value:  &#x60;&#x60;&#x60; \&quot;additionalMetaData\&quot;: [{  \&quot;key1\&quot;: \&quot;value1\&quot;,  \&quot;key2\&quot;: \&quot;value2\&quot; }] &#x60;&#x60;&#x60;
     *
     * @param profileid System profile id (required)
     * @param body      Test run parameters (required)
     * @return TestRun
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public TestRun postTestRun(String profileid, TestRunDefinition body) throws ApiException {
        ApiResponse<TestRun> resp = postTestRunWithHttpInfo(profileid, body);
        return resp.getData();
    }

    /**
     * Register test run
     * Register a test run with provided parameters. The reply contains all test run&#39;s details including the UUID.  - **category** is limited to one of the following values: &#39;unit&#39; (default), &#39;uidriven&#39;, &#39;performance&#39;, &#39;webapi&#39; or &#39;external&#39;. - **marker** is a label used in the Test Automation dashlet charts. - if the **platform** is left blank, the agent will detect it automatically. - if the **includedMetrics** is provided, only test results for these metrics will be collected in this test run. In order to collect all test results for a given metric group you can pass just the group name or leave the metric name blank. - **additionalMetaData** can be used to provide additional data stored in Test Run, like Jenkins build ID, list of commiters, etc. Example Value:  &#x60;&#x60;&#x60; \&quot;additionalMetaData\&quot;: [{  \&quot;key1\&quot;: \&quot;value1\&quot;,  \&quot;key2\&quot;: \&quot;value2\&quot; }] &#x60;&#x60;&#x60;
     *
     * @param profileid System profile id (required)
     * @param body      Test run parameters (required)
     * @return ApiResponse&lt;TestRun&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<TestRun> postTestRunWithHttpInfo(String profileid, TestRunDefinition body) throws ApiException {
        Call call = postTestRunValidateBeforeCall(profileid, body, null, null);
        Type localVarReturnType = new TypeToken<TestRun>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Build call for searchTestRuns
     *
     * @param profileid               System profile id (required)
     * @param body                    Test run filter (optional)
     * @param progressListener        Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call searchTestRunsCall(String profileid, TestRunFilter body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // create path and map variables
        String localVarPath = "/profiles/{profileid}/testruns/search"
                .replaceAll("\\{" + "profileid" + "\\}", apiClient.escapeString(profileid));

        List<Pair> localVarQueryParams = new ArrayList<>();

        Map<String, String> localVarHeaderParams = new HashMap<>();

        Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
                "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
                "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if (progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                            .build();
                }
            });
        }

        String[] localVarAuthNames = new String[]{"basicAuth"};
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, body, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call searchTestRunsValidateBeforeCall(String profileid, TestRunFilter body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        // verify the required parameter 'profileid' is set
        if (profileid == null) {
            throw new ApiException("Missing the required parameter 'profileid' when calling searchTestRuns(Async)");
        }

        return searchTestRunsCall(profileid, body, progressListener, progressRequestListener);
    }

    /**
     * Search and filter test runs by System Profile
     * Returns a list of registered test runs for a given System Profile that have test executions. You can control the time range of included data with &#39;timeframestart&#39;, &#39;timeframeend&#39;, &#39;lastntestruns&#39; and &#39;lastnbuilds&#39; filter properties. The level of detail can be controlled with the &#39;extend&#39; filter property.
     *
     * @param profileid System profile id (required)
     * @param body      Test run filter (optional)
     * @return TestRuns
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public TestRuns searchTestRuns(String profileid, TestRunFilter body) throws ApiException {
        ApiResponse<TestRuns> resp = searchTestRunsWithHttpInfo(profileid, body);
        return resp.getData();
    }

    /**
     * Search and filter test runs by System Profile
     * Returns a list of registered test runs for a given System Profile that have test executions. You can control the time range of included data with &#39;timeframestart&#39;, &#39;timeframeend&#39;, &#39;lastntestruns&#39; and &#39;lastnbuilds&#39; filter properties. The level of detail can be controlled with the &#39;extend&#39; filter property.
     *
     * @param profileid System profile id (required)
     * @param body      Test run filter (optional)
     * @return ApiResponse&lt;TestRuns&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<TestRuns> searchTestRunsWithHttpInfo(String profileid, TestRunFilter body) throws ApiException {
        Call call = searchTestRunsValidateBeforeCall(profileid, body, null, null);
        Type localVarReturnType = new TypeToken<TestRuns>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }
}
